
# HG changeset patch
# User Otto LÃ¤nd <bind-autoland@mozilla.com>
# Date 1714136896 0
# Node ID cef76365b0118f0062385a73909d7a7b427fdf2a
# Parent  fe050f00b35a8a1d503e218c0f8ed181dc935629
Bug 1889978: apply code formatting via Lando

# ignore-this-changeset

diff --git a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
@@ -164,17 +164,17 @@ FFmpegLibWrapper::LinkResult FFmpegLibWr
   AV_FUNC(avcodec_find_encoder, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_find_encoder_by_name,
           AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC(avcodec_flush_buffers, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_open2, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_register_all, AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 |
                                     AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58)
   AV_FUNC(av_init_packet, (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58 |
-                              AV_FUNC_59 | AV_FUNC_60))
+                           AV_FUNC_59 | AV_FUNC_60))
   AV_FUNC(av_parser_init, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(av_parser_close, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(av_parser_parse2, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_align_dimensions, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_alloc_frame, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_get_frame_defaults, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_free_frame, AV_FUNC_54)
   AV_FUNC(avcodec_send_packet,
@@ -272,19 +272,19 @@ FFmpegLibWrapper::LinkResult FFmpegLibWr
   AV_FUNC_OPTION_SILENT(av_hwframe_transfer_get_formats,
                         AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_create_derived,
                         AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwframe_ctx_alloc,
                         AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(avcodec_get_name, AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 |
                                               AV_FUNC_60 | AV_FUNC_61)
-  AV_FUNC_OPTION_SILENT(
-      av_get_pix_fmt_string,
-      AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
+  AV_FUNC_OPTION_SILENT(av_get_pix_fmt_string,
+                        AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 |
+                            AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
 #endif
 
   AV_FUNC_OPTION(av_tx_init, AV_FUNC_AVUTIL_ALL)
   AV_FUNC_OPTION(av_tx_uninit, AV_FUNC_AVUTIL_ALL)
 
 #undef AV_FUNC
 #undef AV_FUNC_OPTION
 
diff --git a/dom/media/platforms/ffmpeg/FFmpegUtils.h b/dom/media/platforms/ffmpeg/FFmpegUtils.h
--- a/dom/media/platforms/ffmpeg/FFmpegUtils.h
+++ b/dom/media/platforms/ffmpeg/FFmpegUtils.h
@@ -47,37 +47,37 @@ inline bool IsVideoCodec(AVCodecID aCode
 #endif
       return true;
     default:
       return false;
   }
 }
 
 // Access the correct location for the channel count, based on ffmpeg version.
-template<typename T>
+template <typename T>
 inline int& ChannelCount(T* aObject) {
 #if LIBAVCODEC_VERSION_MAJOR <= 59
   return aObject->channels;
 #else
   return aObject->ch_layout.nb_channels;
 #endif
 }
 
 // Access the correct location for the duration, based on ffmpeg version.
-template<typename T>
+template <typename T>
 inline int64_t& Duration(T* aObject) {
 #if LIBAVCODEC_VERSION_MAJOR < 61
   return aObject->pkt_duration;
 #else
   return aObject->duration;
 #endif
 }
 
 // Access the correct location for the duration, based on ffmpeg version.
-template<typename T>
+template <typename T>
 inline const int64_t& Duration(const T* aObject) {
 #if LIBAVCODEC_VERSION_MAJOR < 61
   return aObject->pkt_duration;
 #else
   return aObject->duration;
 #endif
 }
 
diff --git a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
@@ -869,17 +869,17 @@ int FFmpegVideoDecoder<LIBAV_VER>::GetVi
   aFrame->linesize[2] = mapped.cr.stride;
 
   aFrame->width = aCodecContext->coded_width;
   aFrame->height = aCodecContext->coded_height;
   aFrame->format = aCodecContext->pix_fmt;
   aFrame->extended_data = aFrame->data;
 #  if LIBAVCODEC_VERSION_MAJOR < 61
   aFrame->reordered_opaque = aCodecContext->reordered_opaque;
-#endif
+#  endif
   MOZ_ASSERT(aFrame->data[0] && aFrame->data[1] && aFrame->data[2]);
 
   // This will hold a reference to image, and the reference would be dropped
   // when ffmpeg tells us that the buffer is no longer needed.
   auto imageWrapper = MakeRefPtr<ImageBufferWrapper>(image.get(), this);
   aFrame->buf[0] =
       mLib->av_buffer_create(aFrame->data[0], dataSize.value(),
                              ReleaseVideoBufferWrapper, imageWrapper.get(), 0);
@@ -1041,19 +1041,17 @@ void FFmpegVideoDecoder<LIBAV_VER>::Deco
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::DoDecode(
     MediaRawData* aSample, uint8_t* aData, int aSize, bool* aGotFrame,
     MediaDataDecoder::DecodedData& aResults) {
   MOZ_ASSERT(mTaskQueue->IsOnCurrentThread());
   AVPacket* packet;
 
 #if LIBAVCODEC_VERSION_MAJOR >= 61
   packet = mLib->av_packet_alloc();
-  auto raii = MakeScopeExit([&]() {
-    mLib->av_packet_free(&packet);
-  });
+  auto raii = MakeScopeExit([&]() { mLib->av_packet_free(&packet); });
 #else
   AVPacket packet_mem;
   packet = &packet_mem;
   mLib->av_init_packet(packet);
 #endif
 
 #if LIBAVCODEC_VERSION_MAJOR >= 58
   mDecodeStats.DecodeStart();
@@ -1176,18 +1174,18 @@ MediaResult FFmpegVideoDecoder<LIBAV_VER
         // Explicitly remove dmabuf surface pool as it's configured
         // for VA-API/V4L2 support.
         mVideoFramePool = nullptr;
         return rv;
       }
     } else
 #  endif
     {
-      rv = CreateImage(mFrame->pkt_pos, GetFramePts(mFrame),
-                       Duration(mFrame), aResults);
+      rv = CreateImage(mFrame->pkt_pos, GetFramePts(mFrame), Duration(mFrame),
+                       aResults);
     }
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     mPerformanceRecorder.Record(mFrame->pkt_dts, [&](auto& aStage) {
       aStage.SetResolution(mFrame->width, mFrame->height);
       auto format = [&]() -> Maybe<DecodeStage::ImageFormat> {

