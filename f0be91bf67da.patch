
# HG changeset patch
# User Paul Adenot <paul@paul.cx>
# Date 1714136726 0
# Node ID f0be91bf67da6d7771e7444085157972500e15ab
# Parent  9ca936580fb84f206b625e837fe4fad4376aa4cf
Bug 1889978 - Make all files using the FFmpeg API compatible with ffmpeg 7.0. r=media-playback-reviewers,alwu

AVCodecContext.channels doesn't exist anymore.
AVCodecContext.ch_layout.nb_channels is the equivalent.

AVFrame.channels also has switched to .ch_layout.nb_channels.

AVFrame.pkt_duration has switched to .duration (same meaning)

AVPacket can't be allocated on the stack, it's size isn't part of the ABI. It
needs to be allocated via av_packet_alloc, and freed using av_packet_free.


AVCodecContext.reordered_opaque doesn't exist anymore, we don't really need it.

Differential Revision: https://phabricator.services.mozilla.com/D206924

diff --git a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
@@ -1,15 +1,16 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "FFmpegAudioDecoder.h"
+#include "FFmpegUtils.h"
 #include "AudioSampleFormat.h"
 #include "FFmpegLog.h"
 #include "TimeUnits.h"
 #include "VideoUtils.h"
 #include "BufferReader.h"
 #include "libavutil/dict.h"
 #include "libavutil/samplefmt.h"
 #if defined(FFVPX_VERSION)
@@ -245,17 +246,17 @@ MediaResult FFmpegAudioDecoder<LIBAV_VER
   }
 
   FFMPEG_LOG("FFmpegAudioDecoder decoded: [%s,%s] (Duration: %s) [%s]",
              aSample->mTime.ToString().get(),
              aSample->GetEndTime().ToString().get(),
              aSample->mDuration.ToString().get(),
              mLib->av_get_sample_fmt_name(mFrame->format));
 
-  uint32_t numChannels = mCodecContext->channels;
+  uint32_t numChannels = ChannelCount(mCodecContext);
   uint32_t samplingRate = mCodecContext->sample_rate;
   if (!numChannels) {
     numChannels = mAudioInfo.mChannels;
   }
   if (!samplingRate) {
     samplingRate = mAudioInfo.mRate;
   }
   AlignedAudioBuffer audio =
@@ -279,17 +280,17 @@ MediaResult FFmpegAudioDecoder<LIBAV_VER
                duration.ToSeconds());
     return MediaResult(
         NS_ERROR_DOM_MEDIA_OVERFLOW_ERR,
         RESULT_DETAIL("Invalid count of accumulated audio samples"));
   }
 
   RefPtr<AudioData> data =
       new AudioData(aSample->mOffset, pts, std::move(audio), numChannels,
-                    samplingRate, mCodecContext->channel_layout);
+                    samplingRate, numChannels);
   MOZ_ASSERT(duration == data->mDuration, "must be equal");
   aResults.AppendElement(std::move(data));
 
   pts = newpts;
 
   if (aGotFrame) {
     *aGotFrame = true;
   }
@@ -390,41 +391,52 @@ MediaResult FFmpegAudioDecoder<LIBAV_VER
 #endif
 
 MediaResult FFmpegAudioDecoder<LIBAV_VER>::DoDecode(MediaRawData* aSample,
                                                     uint8_t* aData, int aSize,
                                                     bool* aGotFrame,
                                                     DecodedData& aResults) {
   MOZ_ASSERT(mTaskQueue->IsOnCurrentThread());
   PROCESS_DECODE_LOG(aSample);
-  AVPacket packet;
-  mLib->av_init_packet(&packet);
+  AVPacket* packet;
+#if LIBAVCODEC_VERSION_MAJOR >= 61
+  packet = mLib->av_packet_alloc();
+#else
+  AVPacket packet_mem;
+  packet = &packet_mem;
+  mLib->av_init_packet(packet);
+#endif
 
   FFMPEG_LOG("FFmpegAudioDecoder::DoDecode: %d bytes, [%s,%s] (Duration: %s)",
              aSize, aSample->mTime.ToString().get(),
              aSample->GetEndTime().ToString().get(),
              aSample->mDuration.ToString().get());
 
-  packet.data = const_cast<uint8_t*>(aData);
-  packet.size = aSize;
+  packet->data = const_cast<uint8_t*>(aData);
+  packet->size = aSize;
 
   if (aGotFrame) {
     *aGotFrame = false;
   }
 
   if (!PrepareFrame()) {
     FFMPEG_LOG("FFmpegAudioDecoder: OOM in PrepareFrame");
     return MediaResult(
         NS_ERROR_OUT_OF_MEMORY,
         RESULT_DETAIL("FFmpeg audio decoder failed to allocate frame"));
   }
 
   bool decoded = false;
-  auto rv = DecodeUsingFFmpeg(&packet, decoded, aSample, aResults, aGotFrame);
+  auto rv = DecodeUsingFFmpeg(packet, decoded, aSample, aResults, aGotFrame);
   NS_ENSURE_SUCCESS(rv, rv);
+
+#if LIBAVCODEC_VERSION_MAJOR >= 61
+  mLib->av_packet_free(&packet);
+#endif
+
   return NS_OK;
 }
 
 AVCodecID FFmpegAudioDecoder<LIBAV_VER>::GetCodecId(const nsACString& aMimeType,
                                                     const AudioInfo& aInfo) {
   if (aMimeType.EqualsLiteral("audio/mp4a-latm")) {
     return AV_CODEC_ID_AAC;
   }
diff --git a/dom/media/platforms/ffmpeg/FFmpegAudioEncoder.cpp b/dom/media/platforms/ffmpeg/FFmpegAudioEncoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegAudioEncoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegAudioEncoder.cpp
@@ -96,22 +96,23 @@ nsresult FFmpegAudioEncoder<LIBAV_VER>::
       FFMPEG_LOG(
           "Error creating resampler in FFmpegAudioEncoder %dHz -> %dHz (%dch)",
           mInputSampleRate, mConfig.mSampleRate, mConfig.mNumberOfChannels);
     }
   }
 
   // And now the audio-specific part
   mCodecContext->sample_rate = AssertedCast<int>(mConfig.mSampleRate);
-  mCodecContext->channels = AssertedCast<int>(mConfig.mNumberOfChannels);
 
 #if LIBAVCODEC_VERSION_MAJOR >= 60
   // Gecko's ordering intentionnally matches ffmepg's ordering
   mLib->av_channel_layout_default(&mCodecContext->ch_layout,
-                                  AssertedCast<int>(mCodecContext->channels));
+                                  AssertedCast<int>(mConfig.mNumberOfChannels));
+#else
+  mCodecContext->channels = AssertedCast<int>(mConfig.mNumberOfChannels);
 #endif
 
   switch (mConfig.mCodec) {
     case CodecType::Opus:
       // When using libopus, ffmpeg supports interleaved float and s16 input.
       mCodecContext->sample_fmt = AV_SAMPLE_FMT_FLT;
       break;
     case CodecType::Vorbis:
@@ -201,17 +202,17 @@ FFmpegAudioEncoder<LIBAV_VER>::EncodeOne
   }
 
   uint32_t frameCount = aSamples.Length() / mConfig.mNumberOfChannels;
 
   // This method assumes that the audio has been packetized appropriately --
   // packets smaller than the packet size are allowed when draining.
   MOZ_ASSERT(AssertedCast<int>(frameCount) <= mCodecContext->frame_size);
 
-  mFrame->channels = AssertedCast<int>(mConfig.mNumberOfChannels);
+  ChannelCount(mFrame) = AssertedCast<int>(mConfig.mNumberOfChannels);
 
 #  if LIBAVCODEC_VERSION_MAJOR >= 60
   int rv = mLib->av_channel_layout_copy(&mFrame->ch_layout,
                                         &mCodecContext->ch_layout);
   if (rv < 0) {
     FFMPEG_LOG("channel layout copy error: %s",
                MakeErrorString(mLib, rv).get());
     return Err(NS_ERROR_DOM_MEDIA_FATAL_ERR);
@@ -224,20 +225,20 @@ FFmpegAudioEncoder<LIBAV_VER>::EncodeOne
   // Audio is converted below if needed
   mFrame->format = mCodecContext->sample_fmt;
   // Set presentation timestamp and duration of the AVFrame.
 #  if LIBAVCODEC_VERSION_MAJOR >= 59
   mFrame->time_base =
       AVRational{.num = 1, .den = static_cast<int>(mConfig.mSampleRate)};
 #  endif
   mFrame->pts = aPts.ToTicksAtRate(mConfig.mSampleRate);
-  mFrame->pkt_duration = frameCount;
 #  if LIBAVCODEC_VERSION_MAJOR >= 60
   mFrame->duration = frameCount;
 #  else
+  mFrame->pkt_duration = frameCount;
   // Save duration in the time_base unit.
   mDurationMap.Insert(mFrame->pts, mFrame->pkt_duration);
 #  endif
 
   if (int ret = mLib->av_frame_get_buffer(mFrame, 16); ret < 0) {
     FFMPEG_LOG("failed to allocate frame data: %s",
                MakeErrorString(mLib, ret).get());
     return Err(NS_ERROR_OUT_OF_MEMORY);
@@ -253,17 +254,17 @@ FFmpegAudioEncoder<LIBAV_VER>::EncodeOne
   // The input is always in f32 interleaved for now
   if (mCodecContext->sample_fmt == AV_SAMPLE_FMT_FLT) {
     PodCopy(reinterpret_cast<float*>(mFrame->data[0]), aSamples.data(),
             aSamples.Length());
   } else {
     MOZ_ASSERT(mCodecContext->sample_fmt == AV_SAMPLE_FMT_FLTP);
     for (uint32_t i = 0; i < mConfig.mNumberOfChannels; i++) {
       DeinterleaveAndConvertBuffer(aSamples.data(), mFrame->nb_samples,
-                                   mFrame->channels, mFrame->data);
+                                   mConfig.mNumberOfChannels, mFrame->data);
     }
   }
 
   // Now send the AVFrame to ffmpeg for encoding, same code for audio and video.
   return FFmpegDataEncoder<LIBAV_VER>::EncodeWithModernAPIs();
 }
 
 Result<MediaDataEncoder::EncodedData, nsresult> FFmpegAudioEncoder<
diff --git a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
@@ -64,26 +64,29 @@ FFmpegLibWrapper::LinkResult FFmpegLibWr
     AV_FUNC_53 = 1 << 0,
     AV_FUNC_54 = 1 << 1,
     AV_FUNC_55 = 1 << 2,
     AV_FUNC_56 = 1 << 3,
     AV_FUNC_57 = 1 << 4,
     AV_FUNC_58 = 1 << 5,
     AV_FUNC_59 = 1 << 6,
     AV_FUNC_60 = 1 << 7,
+    AV_FUNC_61 = 1 << 7,
     AV_FUNC_AVUTIL_53 = AV_FUNC_53 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_54 = AV_FUNC_54 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_55 = AV_FUNC_55 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_56 = AV_FUNC_56 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_57 = AV_FUNC_57 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_58 = AV_FUNC_58 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_59 = AV_FUNC_59 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_60 = AV_FUNC_60 | AV_FUNC_AVUTIL_MASK,
+    AV_FUNC_AVUTIL_61 = AV_FUNC_61 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVCODEC_ALL = AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 | AV_FUNC_56 |
-                          AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60,
+                          AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 |
+                          AV_FUNC_61,
     AV_FUNC_AVUTIL_ALL = AV_FUNC_AVCODEC_ALL | AV_FUNC_AVUTIL_MASK
   };
 
   switch (macro) {
     case 53:
       version = AV_FUNC_53;
       break;
     case 54:
@@ -102,16 +105,19 @@ FFmpegLibWrapper::LinkResult FFmpegLibWr
       version = AV_FUNC_58;
       break;
     case 59:
       version = AV_FUNC_59;
       break;
     case 60:
       version = AV_FUNC_60;
       break;
+    case 61:
+      version = AV_FUNC_61;
+      break;
     default:
       FFMPEGV_LOG("Unknown avcodec version: %d", macro);
       Unlink();
       return isFFMpeg ? ((macro > 57) ? LinkResult::UnknownFutureFFMpegVersion
                                       : LinkResult::UnknownOlderFFMpegVersion)
                       // All LibAV versions<54.35.1 are blocked, therefore we
                       // must be dealing with a later one.
                       : LinkResult::UnknownFutureLibAVVersion;
@@ -148,116 +154,137 @@ FFmpegLibWrapper::LinkResult FFmpegLibWr
                                    AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58)
   AV_FUNC(avcodec_alloc_context3, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_close, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_decode_audio4, AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 |
                                      AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58)
   AV_FUNC(avcodec_decode_video2, AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 |
                                      AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58)
   AV_FUNC(avcodec_find_decoder, AV_FUNC_AVCODEC_ALL)
-  AV_FUNC(avcodec_find_decoder_by_name, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC(avcodec_find_decoder_by_name,
+          AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC(avcodec_find_encoder, AV_FUNC_AVCODEC_ALL)
-  AV_FUNC(avcodec_find_encoder_by_name, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC(avcodec_find_encoder_by_name,
+          AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC(avcodec_flush_buffers, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_open2, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_register_all, AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 |
                                     AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58)
-  AV_FUNC(av_init_packet, AV_FUNC_AVCODEC_ALL)
+  AV_FUNC(av_init_packet, (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58 |
+                              AV_FUNC_59 | AV_FUNC_60))
   AV_FUNC(av_parser_init, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(av_parser_close, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(av_parser_parse2, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_align_dimensions, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(avcodec_alloc_frame, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_get_frame_defaults, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_free_frame, AV_FUNC_54)
-  AV_FUNC(avcodec_send_packet, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC(avcodec_receive_packet, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC(avcodec_send_frame, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC(avcodec_receive_frame, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC(avcodec_default_get_buffer2, (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 |
-                                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60))
-  AV_FUNC(av_packet_alloc, (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60))
-  AV_FUNC(av_packet_unref, (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60))
-  AV_FUNC(av_packet_free, (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60))
+  AV_FUNC(avcodec_send_packet,
+          AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC(avcodec_receive_packet,
+          AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC(avcodec_send_frame, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC(avcodec_receive_frame,
+          AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC(avcodec_default_get_buffer2,
+          (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 |
+           AV_FUNC_60 | AV_FUNC_61))
+  AV_FUNC(av_packet_alloc,
+          (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61))
+  AV_FUNC(av_packet_unref,
+          (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61))
+  AV_FUNC(av_packet_free,
+          (AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61))
   AV_FUNC(avcodec_descriptor_get, AV_FUNC_AVCODEC_ALL)
   AV_FUNC(av_log_set_level, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_malloc, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_freep, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_frame_alloc,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 |
+           AV_FUNC_AVUTIL_61))
   AV_FUNC(av_frame_free,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 |
+           AV_FUNC_AVUTIL_61))
   AV_FUNC(av_frame_unref,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 |
+           AV_FUNC_AVUTIL_61))
   AV_FUNC(av_frame_get_buffer,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 |
+           AV_FUNC_AVUTIL_61))
   AV_FUNC(av_frame_make_writable,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 |
+           AV_FUNC_AVUTIL_61))
   AV_FUNC(av_image_check_size, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_image_get_buffer_size, AV_FUNC_AVUTIL_ALL)
-  AV_FUNC_OPTION(av_channel_layout_default, AV_FUNC_AVUTIL_60)
-  AV_FUNC_OPTION(av_channel_layout_from_mask, AV_FUNC_AVUTIL_60)
-  AV_FUNC_OPTION(av_channel_layout_copy, AV_FUNC_AVUTIL_60)
+  AV_FUNC_OPTION(av_channel_layout_default,
+                 AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
+  AV_FUNC_OPTION(av_channel_layout_from_mask,
+                 AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
+  AV_FUNC_OPTION(av_channel_layout_copy, AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
   AV_FUNC_OPTION(av_buffer_get_opaque,
                  (AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 | AV_FUNC_AVUTIL_58 |
-                  AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
-  AV_FUNC(av_buffer_create,
-          (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
+                  AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61))
+  AV_FUNC(
+      av_buffer_create,
+      (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
+       AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 | AV_FUNC_61))
   AV_FUNC_OPTION(av_frame_get_colorspace,
                  AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
                      AV_FUNC_AVUTIL_58)
   AV_FUNC_OPTION(av_frame_get_color_range,
                  AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
                      AV_FUNC_AVUTIL_58)
-  AV_FUNC(av_strerror,
-          AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60)
+  AV_FUNC(av_strerror, AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 |
+                           AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
   AV_FUNC(av_get_sample_fmt_name, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_dict_set, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_dict_free, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_opt_set, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_opt_set_double, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_opt_set_int, AV_FUNC_AVUTIL_ALL)
 
 #ifdef MOZ_WIDGET_GTK
   AV_FUNC_OPTION_SILENT(avcodec_get_hw_config,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC_OPTION_SILENT(av_codec_iterate, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC_OPTION_SILENT(av_codec_iterate,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_codec_is_decoder,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_init,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_alloc,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_hwconfig_alloc,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_get_hwframe_constraints,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwframe_constraints_free,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC_OPTION_SILENT(av_buffer_ref,
-                        AV_FUNC_AVUTIL_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC_OPTION_SILENT(av_buffer_unref,
-                        AV_FUNC_AVUTIL_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC_OPTION_SILENT(av_buffer_ref, AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 |
+                                           AV_FUNC_AVUTIL_60 |
+                                           AV_FUNC_AVUTIL_61)
+  AV_FUNC_OPTION_SILENT(av_buffer_unref, AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 |
+                                             AV_FUNC_AVUTIL_60 |
+                                             AV_FUNC_AVUTIL_61)
   AV_FUNC_OPTION_SILENT(av_hwframe_transfer_get_formats,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_create_derived,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
   AV_FUNC_OPTION_SILENT(av_hwframe_ctx_alloc,
-                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC_OPTION_SILENT(avcodec_get_name,
-                        AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
-  AV_FUNC_OPTION_SILENT(av_get_pix_fmt_string, AV_FUNC_AVUTIL_58 |
-                                                   AV_FUNC_AVUTIL_59 |
-                                                   AV_FUNC_AVUTIL_60)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC_OPTION_SILENT(avcodec_get_name, AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 |
+                                              AV_FUNC_60 | AV_FUNC_61)
+  AV_FUNC_OPTION_SILENT(
+      av_get_pix_fmt_string,
+      AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60 | AV_FUNC_AVUTIL_61)
 #endif
 
   AV_FUNC_OPTION(av_tx_init, AV_FUNC_AVUTIL_ALL)
   AV_FUNC_OPTION(av_tx_uninit, AV_FUNC_AVUTIL_ALL)
 
 #undef AV_FUNC
 #undef AV_FUNC_OPTION
 
diff --git a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.h b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.h
--- a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.h
+++ b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.h
@@ -133,20 +133,22 @@ struct MOZ_ONLY_USED_TO_AVOID_STATIC_CON
   // libavcodec v54 only
   void (*avcodec_free_frame)(AVFrame** frame);
 
   // libavcodec >= v55
   int (*avcodec_default_get_buffer2)(AVCodecContext* s, AVFrame* frame,
                                      int flags);
 
   // libavcodec >= v57
-  AVPacket* (*av_packet_alloc)(void);
   void (*av_packet_unref)(AVPacket* pkt);
   void (*av_packet_free)(AVPacket** pkt);
 
+  // libavcodec >= 61
+  AVPacket* (*av_packet_alloc)();
+
   // libavcodec v58 and later only
   int (*avcodec_send_packet)(AVCodecContext* avctx, const AVPacket* avpkt);
   int (*avcodec_receive_packet)(AVCodecContext* avctx, AVPacket* avpkt);
   int (*avcodec_send_frame)(AVCodecContext* avctx, const AVFrame* frame);
   int (*avcodec_receive_frame)(AVCodecContext* avctx, AVFrame* frame);
 
   // libavutil
   void (*av_log_set_level)(int level);
diff --git a/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp b/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp
@@ -28,28 +28,30 @@ class FFmpegEncoderModule {
   static already_AddRefed<PlatformEncoderModule> Create(FFmpegLibWrapper*);
 };
 
 static FFmpegLibWrapper sLibAV;
 
 static const char* sLibs[] = {
 // clang-format off
 #if defined(XP_DARWIN)
+  "libavcodec.61.dylib",
   "libavcodec.60.dylib",
   "libavcodec.59.dylib",
   "libavcodec.58.dylib",
   "libavcodec.57.dylib",
   "libavcodec.56.dylib",
   "libavcodec.55.dylib",
   "libavcodec.54.dylib",
   "libavcodec.53.dylib",
 #elif defined(XP_OPENBSD)
   "libavcodec.so", // OpenBSD hardly controls the major/minor library version
                    // of ffmpeg and update it regulary on ABI/API changes
 #else
+  "libavcodec.so.61",
   "libavcodec.so.60",
   "libavcodec.so.59",
   "libavcodec.so.58",
   "libavcodec-ffmpeg.so.58",
   "libavcodec-ffmpeg.so.57",
   "libavcodec-ffmpeg.so.56",
   "libavcodec.so.57",
   "libavcodec.so.56",
@@ -169,16 +171,19 @@ already_AddRefed<PlatformDecoderModule> 
       module = FFmpegDecoderModule<58>::Create(&sLibAV);
       break;
     case 59:
       module = FFmpegDecoderModule<59>::Create(&sLibAV);
       break;
     case 60:
       module = FFmpegDecoderModule<60>::Create(&sLibAV);
       break;
+    case 61:
+      module = FFmpegDecoderModule<61>::Create(&sLibAV);
+      break;
     default:
       module = nullptr;
   }
   return module.forget();
 }
 
 /* static */
 already_AddRefed<PlatformEncoderModule> FFmpegRuntimeLinker::CreateEncoder() {
@@ -204,16 +209,19 @@ already_AddRefed<PlatformEncoderModule> 
       module = FFmpegEncoderModule<58>::Create(&sLibAV);
       break;
     case 59:
       module = FFmpegEncoderModule<59>::Create(&sLibAV);
       break;
     case 60:
       module = FFmpegEncoderModule<60>::Create(&sLibAV);
       break;
+    case 61:
+      module = FFmpegEncoderModule<61>::Create(&sLibAV);
+      break;
     default:
       module = nullptr;
   }
   return module.forget();
 }
 
 /* static */ const char* FFmpegRuntimeLinker::LinkStatusString() {
   switch (sLinkStatus) {
diff --git a/dom/media/platforms/ffmpeg/FFmpegUtils.h b/dom/media/platforms/ffmpeg/FFmpegUtils.h
--- a/dom/media/platforms/ffmpeg/FFmpegUtils.h
+++ b/dom/media/platforms/ffmpeg/FFmpegUtils.h
@@ -46,11 +46,41 @@ inline bool IsVideoCodec(AVCodecID aCode
     case AV_CODEC_ID_AV1:
 #endif
       return true;
     default:
       return false;
   }
 }
 
+// Access the correct location for the channel count, based on ffmpeg version.
+template<typename T>
+inline int& ChannelCount(T* aObject) {
+#if LIBAVCODEC_VERSION_MAJOR <= 59
+  return aObject->channels;
+#else
+  return aObject->ch_layout.nb_channels;
+#endif
+}
+
+// Access the correct location for the duration, based on ffmpeg version.
+template<typename T>
+inline int64_t& Duration(T* aObject) {
+#if LIBAVCODEC_VERSION_MAJOR < 61
+  return aObject->pkt_duration;
+#else
+  return aObject->duration;
+#endif
+}
+
+// Access the correct location for the duration, based on ffmpeg version.
+template<typename T>
+inline const int64_t& Duration(const T* aObject) {
+#if LIBAVCODEC_VERSION_MAJOR < 61
+  return aObject->pkt_duration;
+#else
+  return aObject->duration;
+#endif
+}
+
 }  // namespace mozilla
 
 #endif  // DOM_MEDIA_PLATFORMS_FFMPEG_FFMPEGUTILS_H_
diff --git a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
@@ -2,16 +2,17 @@
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "FFmpegVideoDecoder.h"
 
 #include "FFmpegLog.h"
+#include "FFmpegUtils.h"
 #include "ImageContainer.h"
 #include "MP4Decoder.h"
 #include "MediaInfo.h"
 #include "VideoUtils.h"
 #include "VPXDecoder.h"
 #include "mozilla/layers/KnowsCompositor.h"
 #if LIBAVCODEC_VERSION_MAJOR >= 57
 #  include "mozilla/layers/TextureClient.h"
@@ -866,17 +867,19 @@ int FFmpegVideoDecoder<LIBAV_VER>::GetVi
   aFrame->linesize[0] = mapped.y.stride;
   aFrame->linesize[1] = mapped.cb.stride;
   aFrame->linesize[2] = mapped.cr.stride;
 
   aFrame->width = aCodecContext->coded_width;
   aFrame->height = aCodecContext->coded_height;
   aFrame->format = aCodecContext->pix_fmt;
   aFrame->extended_data = aFrame->data;
+#  if LIBAVCODEC_VERSION_MAJOR < 61
   aFrame->reordered_opaque = aCodecContext->reordered_opaque;
+#endif
   MOZ_ASSERT(aFrame->data[0] && aFrame->data[1] && aFrame->data[2]);
 
   // This will hold a reference to image, and the reference would be dropped
   // when ffmpeg tells us that the buffer is no longer needed.
   auto imageWrapper = MakeRefPtr<ImageBufferWrapper>(image.get(), this);
   aFrame->buf[0] =
       mLib->av_buffer_create(aFrame->data[0], dataSize.value(),
                              ReleaseVideoBufferWrapper, imageWrapper.get(), 0);
@@ -986,22 +989,17 @@ bool FFmpegVideoDecoder<LIBAV_VER>::Deco
 }
 
 void FFmpegVideoDecoder<LIBAV_VER>::DecodeStats::UpdateDecodeTimes(
     const AVFrame* aFrame) {
   TimeStamp now = TimeStamp::Now();
   float decodeTime = (now - mDecodeStart).ToMilliseconds();
   mDecodeStart = now;
 
-  if (aFrame->pkt_duration <= 0) {
-    FFMPEGV_LOG("Incorrect frame duration, skipping decode stats.");
-    return;
-  }
-
-  float frameDuration = aFrame->pkt_duration / 1000.0f;
+  const float frameDuration = Duration(aFrame) / 1000.0f;
 
   mDecodedFrames++;
   mAverageFrameDuration =
       (mAverageFrameDuration * (mDecodedFrames - 1) + frameDuration) /
       mDecodedFrames;
   mAverageFrameDecodeTime =
       (mAverageFrameDecodeTime * (mDecodedFrames - 1) + decodeTime) /
       mDecodedFrames;
@@ -1039,29 +1037,39 @@ void FFmpegVideoDecoder<LIBAV_VER>::Deco
   }
 }
 #endif
 
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::DoDecode(
     MediaRawData* aSample, uint8_t* aData, int aSize, bool* aGotFrame,
     MediaDataDecoder::DecodedData& aResults) {
   MOZ_ASSERT(mTaskQueue->IsOnCurrentThread());
-  AVPacket packet;
-  mLib->av_init_packet(&packet);
+  AVPacket* packet;
+
+#if LIBAVCODEC_VERSION_MAJOR >= 61
+  packet = mLib->av_packet_alloc();
+  auto raii = MakeScopeExit([&]() {
+    mLib->av_packet_free(&packet);
+  });
+#else
+  AVPacket packet_mem;
+  packet = &packet_mem;
+  mLib->av_init_packet(packet);
+#endif
 
 #if LIBAVCODEC_VERSION_MAJOR >= 58
   mDecodeStats.DecodeStart();
 #endif
 
-  packet.data = aData;
-  packet.size = aSize;
-  packet.dts = aSample->mTimecode.ToMicroseconds();
-  packet.pts = aSample->mTime.ToMicroseconds();
-  packet.flags = aSample->mKeyframe ? AV_PKT_FLAG_KEY : 0;
-  packet.pos = aSample->mOffset;
+  packet->data = aData;
+  packet->size = aSize;
+  packet->dts = aSample->mTimecode.ToMicroseconds();
+  packet->pts = aSample->mTime.ToMicroseconds();
+  packet->flags = aSample->mKeyframe ? AV_PKT_FLAG_KEY : 0;
+  packet->pos = aSample->mOffset;
 
   mTrackingId.apply([&](const auto& aId) {
     MediaInfoFlag flag = MediaInfoFlag::None;
     flag |= (aSample->mKeyframe ? MediaInfoFlag::KeyFrame
                                 : MediaInfoFlag::NonKeyFrame);
     flag |= (IsHardwareAccelerated() ? MediaInfoFlag::HardwareDecoding
                                      : MediaInfoFlag::SoftwareDecoding);
     switch (mCodecID) {
@@ -1082,24 +1090,24 @@ MediaResult FFmpegVideoDecoder<LIBAV_VER
       case AV_CODEC_ID_AV1:
         flag |= MediaInfoFlag::VIDEO_AV1;
         break;
 #endif
       default:
         break;
     }
     mPerformanceRecorder.Start(
-        packet.dts,
+        packet->dts,
         nsPrintfCString("FFmpegVideoDecoder(%d)", LIBAVCODEC_VERSION_MAJOR),
         aId, flag);
   });
 
 #if LIBAVCODEC_VERSION_MAJOR >= 58
-  packet.duration = aSample->mDuration.ToMicroseconds();
-  int res = mLib->avcodec_send_packet(mCodecContext, &packet);
+  packet->duration = aSample->mDuration.ToMicroseconds();
+  int res = mLib->avcodec_send_packet(mCodecContext, packet);
   if (res < 0) {
     // In theory, avcodec_send_packet could sent -EAGAIN should its internal
     // buffers be full. In practice this can't happen as we only feed one frame
     // at a time, and we immediately call avcodec_receive_frame right after.
     char errStr[AV_ERROR_MAX_STRING_SIZE];
     mLib->av_strerror(res, errStr, AV_ERROR_MAX_STRING_SIZE);
     FFMPEG_LOG("avcodec_send_packet error: %s", errStr);
     return MediaResult(res == int(AVERROR_EOF)
@@ -1151,35 +1159,35 @@ MediaResult FFmpegVideoDecoder<LIBAV_VER
                              "Fallback to SW decode");
         FFMPEG_LOG("  HW decoding is slow, switch back to SW decode");
         return MediaResult(
             NS_ERROR_DOM_MEDIA_DECODE_ERR,
             RESULT_DETAIL("HW decoding is slow, switch back to SW decode"));
       }
       if (mUsingV4L2) {
         rv = CreateImageV4L2(mFrame->pkt_pos, GetFramePts(mFrame),
-                             mFrame->pkt_duration, aResults);
+                             Duration(mFrame), aResults);
       } else {
         rv = CreateImageVAAPI(mFrame->pkt_pos, GetFramePts(mFrame),
-                              mFrame->pkt_duration, aResults);
+                              Duration(mFrame), aResults);
       }
 
       // If VA-API/V4L2 playback failed, just quit. Decoder is going to be
       // restarted without hardware acceleration
       if (NS_FAILED(rv)) {
         // Explicitly remove dmabuf surface pool as it's configured
         // for VA-API/V4L2 support.
         mVideoFramePool = nullptr;
         return rv;
       }
     } else
 #  endif
     {
       rv = CreateImage(mFrame->pkt_pos, GetFramePts(mFrame),
-                       mFrame->pkt_duration, aResults);
+                       Duration(mFrame), aResults);
     }
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     mPerformanceRecorder.Record(mFrame->pkt_dts, [&](auto& aStage) {
       aStage.SetResolution(mFrame->width, mFrame->height);
       auto format = [&]() -> Maybe<DecodeStage::ImageFormat> {
@@ -1234,24 +1242,24 @@ MediaResult FFmpegVideoDecoder<LIBAV_VER
     return MediaResult(NS_ERROR_OUT_OF_MEMORY, __func__);
   }
 
   // Required with old version of FFmpeg/LibAV
   mFrame->reordered_opaque = AV_NOPTS_VALUE;
 
   int decoded;
   int bytesConsumed =
-      mLib->avcodec_decode_video2(mCodecContext, mFrame, &decoded, &packet);
+      mLib->avcodec_decode_video2(mCodecContext, mFrame, &decoded, packet);
 
   FFMPEG_LOG(
       "DoDecodeFrame:decode_video: rv=%d decoded=%d "
       "(Input: pts(%" PRId64 ") dts(%" PRId64 ") Output: pts(%" PRId64
       ") "
       "opaque(%" PRId64 ") pts(%" PRId64 ") pkt_dts(%" PRId64 "))",
-      bytesConsumed, decoded, packet.pts, packet.dts, mFrame->pts,
+      bytesConsumed, decoded, packet->pts, packet->dts, mFrame->pts,
       mFrame->reordered_opaque, mFrame->pts, mFrame->pkt_dts);
 
   if (bytesConsumed < 0) {
     return MediaResult(NS_ERROR_DOM_MEDIA_DECODE_ERR,
                        RESULT_DETAIL("FFmpeg video error: %d", bytesConsumed));
   }
 
   if (!decoded) {
@@ -1369,18 +1377,18 @@ gfx::ColorRange FFmpegVideoDecoder<LIBAV
 #endif
   return GetColorRange(range);
 }
 
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::CreateImage(
     int64_t aOffset, int64_t aPts, int64_t aDuration,
     MediaDataDecoder::DecodedData& aResults) const {
   FFMPEG_LOG("Got one frame output with pts=%" PRId64 " dts=%" PRId64
-             " duration=%" PRId64 " opaque=%" PRId64,
-             aPts, mFrame->pkt_dts, aDuration, mCodecContext->reordered_opaque);
+             " duration=%" PRId64,
+             aPts, mFrame->pkt_dts, aDuration);
 
   VideoData::YCbCrBuffer b;
   b.mPlanes[0].mData = mFrame->data[0];
   b.mPlanes[1].mData = mFrame->data[1];
   b.mPlanes[2].mData = mFrame->data[2];
 
   b.mPlanes[0].mStride = mFrame->linesize[0];
   b.mPlanes[1].mStride = mFrame->linesize[1];
@@ -1498,18 +1506,18 @@ bool FFmpegVideoDecoder<LIBAV_VER>::GetV
   }
   return true;
 }
 
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::CreateImageVAAPI(
     int64_t aOffset, int64_t aPts, int64_t aDuration,
     MediaDataDecoder::DecodedData& aResults) {
   FFMPEG_LOG("VA-API Got one frame output with pts=%" PRId64 " dts=%" PRId64
-             " duration=%" PRId64 " opaque=%" PRId64,
-             aPts, mFrame->pkt_dts, aDuration, mCodecContext->reordered_opaque);
+             " duration=%" PRId64,
+             aPts, mFrame->pkt_dts, aDuration);
 
   VADRMPRIMESurfaceDescriptor vaDesc;
   if (!GetVAAPISurfaceDescriptor(&vaDesc)) {
     return MediaResult(
         NS_ERROR_DOM_MEDIA_DECODE_ERR,
         RESULT_DETAIL("Unable to get frame by vaExportSurfaceHandle()"));
   }
   auto releaseSurfaceDescriptor = MakeScopeExit(
@@ -1544,18 +1552,18 @@ MediaResult FFmpegVideoDecoder<LIBAV_VER
   aResults.AppendElement(std::move(vp));
   return NS_OK;
 }
 
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::CreateImageV4L2(
     int64_t aOffset, int64_t aPts, int64_t aDuration,
     MediaDataDecoder::DecodedData& aResults) {
   FFMPEG_LOG("V4L2 Got one frame output with pts=%" PRId64 " dts=%" PRId64
-             " duration=%" PRId64 " opaque=%" PRId64,
-             aPts, mFrame->pkt_dts, aDuration, mCodecContext->reordered_opaque);
+             " duration=%" PRId64,
+             aPts, mFrame->pkt_dts, aDuration);
 
   AVDRMFrameDescriptor* desc = (AVDRMFrameDescriptor*)mFrame->data[0];
   if (!desc) {
     return MediaResult(NS_ERROR_DOM_MEDIA_DECODE_ERR,
                        RESULT_DETAIL("Missing DRM PRIME descriptor in frame"));
   }
 
   // Note that the FDs in desc are owned by FFmpeg and it will reuse them
diff --git a/dom/media/platforms/ffmpeg/FFmpegVideoEncoder.cpp b/dom/media/platforms/ffmpeg/FFmpegVideoEncoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegVideoEncoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoEncoder.cpp
@@ -505,17 +505,17 @@ Result<MediaDataEncoder::EncodedData, ns
 #  endif
   mFrame->pts = aSample->mTime.ToMicroseconds();
 #  if LIBAVCODEC_VERSION_MAJOR >= 60
   mFrame->duration = aSample->mDuration.ToMicroseconds();
 #  else
   // Save duration in the time_base unit.
   mDurationMap.Insert(mFrame->pts, aSample->mDuration.ToMicroseconds());
 #  endif
-  mFrame->pkt_duration = aSample->mDuration.ToMicroseconds();
+  Duration(mFrame) = aSample->mDuration.ToMicroseconds();
 
   // Now send the AVFrame to ffmpeg for encoding, same code for audio and video.
   return FFmpegDataEncoder<LIBAV_VER>::EncodeWithModernAPIs();
 }
 #endif  // if LIBAVCODEC_VERSION_MAJOR >= 58
 
 RefPtr<MediaRawData> FFmpegVideoEncoder<LIBAV_VER>::ToMediaRawData(
     AVPacket* aPacket) {

